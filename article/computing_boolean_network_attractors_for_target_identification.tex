%Copyright (c) 2013-2014, Arnaud Poret
%All rights reserved.

\documentclass[oneside,a4paper,onecolumn,notitlepage]{article}

%\usepackage{syntonly}
%\syntaxonly
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithmic}
\usepackage{url}
\usepackage{IEEEtrantools}
\usepackage[utf8]{inputenc}

\algsetup{indent=2em}
\algsetup{linenodelimiter=}

\renewcommand{\algorithmicrequire}{\textbf{input}}
\renewcommand{\algorithmicensure}{\textbf{output}}

\begin{document}

\title{Computing boolean network attractors for target identification}
\author{Arnaud Poret\footnote{Copyright (c) 2013-2014, Arnaud Poret. All rights reserved. arnaud.poret@gmail.com}}
\date{}
\pagestyle{headings}

\maketitle
\tableofcontents

\begin{abstract}
Target identification aims at identifying, in pathologically disturbed biological systems, biomolecules whose function should be therapeutically modified in order to alleviate, or ultimately cure, the physiological consequences of the corresponding pathology. In an attempt to improve the efforts made in this area thanks to \textit{in silico} tools, an algorithm based on the computation of boolean network attractors is proposed. It assumes that the attractors of a dynamical system, such as a boolean network, correspond to the phenotypes produced by the modeled biological network. Under this assumption, the algorithm identifies target combinations together with the therapeutic modifications to be applied to them, here called bullets, which allow pathologically disturbed biological networks to avoid attractors responsible for pathological phenotypes.

The algorithm was tested on a published boolean model of the mammalian cell cycle where the retinoblastoma protein was constitutively inactivated as seen in diseases such as cancer. It returned four effective bullets able to remove the attractors responsible for pathological phenotypes, that is the attractors not reached by the non-pathologically disturbed biological network.

Under the assumption linking dynamical system attractors and biological network phenotypes, the results showed that the algorithm succeeds in performing the proposed \textit{in silico} target identification. However, as with any \textit{in silico} evidence, it should be considered as such: there is a bridge to cross between theory and practice. Nevertheless, it is expected that the algorithm will take its place in, and contribute to, work done in target identification.
\end{abstract}

\section{Background}
Target discovery aims at identifying new effective drugs against diseases. This process can be segmented into three steps \cite{lindsay2003target}: i) disease model provision, where experimental models of the disease are developed, ii) target identification, where new therapeutic targets are proposed and iii) target validation, where the proposed therapeutic targets are assessed. The present work focuses on the second step of target discovery: target identification.

Given an organism suffering from a disease, it aims at finding where to act among its multitude of biomolecules in order to alleviate, or ultimately to cure, the physiological consequences of the disease, hence improving the life quality or quantity of the ill organism \cite{knowles2003target}. These biomolecules on which perturbations should be applied are called targets and are targeted by drugs \cite{imming2006drugs}. This raises two questions: which target should be therapeutically perturbed and what type of perturbation should be applied to it. These two questions can be unified by stating that the perturbation aims at modifying the biological function of the target thanks to its interaction with a drug. Broadly, the functional modification of a target by a drug can be either activating or inactivating, regardless the way the drug achieves it.

Basically, given an organism and a disease, one solution is to test all, or at least a large number of, its biomolecules for activation or inactivation and knowing that it is possibly more effective to target more than one biomolecule \cite{zimmermann2007multi}, the number of possibilities is consequently huge \cite{ohlstein2000drug}. This rather brute force method can be refined with knowledge about the disease pathophysiology by identifying some potential targets based on the role their biological function plays in it \cite{gibbs2000mechanism}. Even with this knowledge, experimentally assessing \textit{in vitro} or \textit{in vivo} the selected potential targets is far from being straightforward. Indeed, such experimentations are costly in time and resources and exhibit a high risk of failure \cite{kaitin2010deconstructing}. Fortunately, \textit{in silico} experimentations appear as valuable tools in improving the efficiency of therapeutic researches \cite{ma2010silico,noble1999biological}. Indeed, \textit{in silico} experimentations are less costly in time and resources than the traditional \textit{in vitro} and \textit{in vivo} experimentations. However, the stumbling block of \textit {in silico} experimentations is that they are built from the available knowledge about the pathophysiology of interest: not all is known about everything. Nevertheless, an impressive and ever increasing amount of biological knowledge is already available through the scientific literature, databases and knowledge bases \cite{chen2002ttd,whirl2012pharmacogenomics,kanehisa2000kegg,croft2011reactome,wishart2008drugbank}. Consequently, this increasing body of knowledge becomes harder and harder to integrate by humans alone because of the complexity of biological systems \cite{kitano2002systems}: this is where computational tools come into play \cite{kitano2002computational}. This interplay between the traditional and the computational biology is synergistic rather than competing \cite{di2006vivo}. Indeed, since \textit{in vitro} and \textit{in vivo} experimentations are rather factual, they are a relatively trustworthy source of knowledge. Once these factual pieces of knowledge are obtained, computational tools can help to integrate them in order to infer new knowledge. Afterwards, this computationally obtained knowledge can be used to direct further \textit{in vitro} or \textit{in vivo} experimentations, hence mutually potentiating the whole.

The goal of the present work is to propose a computational method implemented in an algorithm for target identification based on the computation of boolean network attractors \cite{bornholdt2008boolean}. It is based on the assumption that the attractors of a boolean network correspond to the phenotypes produced by the modeled biological network, an assumption successfully applied in several computations \cite{huang2000shape,davidich2008boolean,faure2006dynamical,fumia2013boolean,creixell2012navigating,baverstock2011comparison}. Indeed, assuming that a phenotype is an observable and hence a relatively stable state of a biological system and assuming that the state of a biological system is due to the dynamic of the underlying biological network, a phenotype is likely to correspond to an attractor. This assumption can be stated for any dynamical model of a biological network but, in this work, only boolean networks are considered. The reason is that, in their most basic form, boolean networks do not require parameter values and that parameter values are not straightforward to obtain in biology \cite{wynn2012logic}, particularly at the sub-cellular scale, the scale where drugs interact with their targets. Moreover, since synchronous boolean networks are easier to compute than asynchronous ones \cite{garg2008synchronous} and given that this work focuses essentially on a computational methodology, only synchronous boolean networks are considered. This does not exclude the possibility, at a later stage, to extend the algorithm for both synchronous and asynchronous boolean networks.

For a biological network involved in a disease pathophysiology, two possible variants are considered: the physiological variant, bore by healthy organisms, which produces physiological phenotypes and the pathological variant, bore by ill organisms, which produces pathological phenotypes or which fails to produce physiological ones. A physiological phenotype does not impair the life quantity or quality of the organism which exhibits it while a pathological phenotype does. It should be noted that the loss of a physiological phenotype is also a pathological condition. The physiological and pathological variants differ in that the second one results from the occurrence of some structural modifications in the network known to be responsible for disorders. Hence, with a pathological variant, there are two non-exclusives pathological scenarios: pathological phenotypes are gained or physiological phenotypes are lost.

The primary goal of the algorithm is to identify, in the pathological variant, target combinations together with the kind of perturbation to apply to them, here called bullets, which make it unable at producing pathological phenotypes. The secondary goal is to classify the obtained bullets according to their ability at making the pathological variant producing the lost physiological phenotypes, if any.

\section{Methods}
\subsection{Preliminaries}
This section briefly introduces biological networks \cite{zhu2007getting} and boolean networks \cite{saadatpour2012boolean}.

\subsubsection{Biological networks}
A network can be seen as a graph $G=(V,E)$ where $V=\lbrace v_1,\dots,v_n\rbrace$ is the set of size $n$ containing exactly all the nodes $v_i$ of the network and where $E=\lbrace (v_{i,1},v_{j,1}),\dots,(v_{i,m},v_{j,m})\rbrace \subseteq V^2$ is the set of size $m$ containing exactly all the edges $(v_{i},v_{j})$ of the network. In practice, nodes represent things and edges represent binary relations $R\subseteq V^2$ involving these things: $v_{i}$ $R$ $v_{j}$. In biological networks, nodes should represent biological entities and edges should represent biological relations. For example, in gene regulatory networks, nodes represent gene products and edges represent gene expression modulation.

\subsubsection{Boolean networks}
A boolean network is a network where nodes are boolean variables $x_i$ and where edges $(x_{i},x_{j})$ represent the binary $is\ input\ of$ relation: $x_{i}$ $is\ input\ of$ $x_{j}$. Each $x_i$ has $b_i\in [\![0,n]\!]$ inputs $x_{i,1},\dots,x_{i,b_i}$ and the variables which are not input of $x_{i}$ have no direct influence on it. In the case where $b_{i}=0$, $x_i$ is a parameter: it does not depend on other variables. At each iteration $k\in [\![k_0,k_{end}]\!]$ of the computation, the value $x_{i}(k)\in \lbrace 0,1\rbrace$ of each $x_i$ is updated to the value $x_{i}(k+1)$ thanks to a boolean function $f_i$ and to the values $x_{i,1}(k),\dots,x_{i,b_i}(k)$ of its inputs:
\begin{algorithmic}[1]
\FOR{$k\in [\![k_0,k_{end}-1]\!]$}
    \STATE $x_{1}(k+1)=f_1(x_{1,1}(k),\dots,x_{1,b_1}(k))$
    \STATE \dots
    \STATE $x_{n}(k+1)=f_n(x_{n,1}(k),\dots,x_{n,b_n}(k))$
\ENDFOR
\end{algorithmic}
which can be written in a more concise form:
\begin{algorithmic}[1]
\FOR{$k\in [\![k_0,k_{end}-1]\!]$}
    \STATE $\boldsymbol{x}(k+1)=\boldsymbol{f}(\boldsymbol{x}(k))$
\ENDFOR
\end{algorithmic}
where $\boldsymbol{f}=(f_1,\dots,f_n)$ is the boolean transition function and $\boldsymbol{x}=(x_1,\dots,x_n)$ is the state vector. The value $\boldsymbol{x}(k)=(x_1(k),\dots,x_n(k))\in \lbrace 0,1\rbrace^n$ of $\boldsymbol{x}$ at $k$ belongs to the state space $S=\lbrace 0,1\rbrace^n$ which is the set of size $2^n$ containing exactly all the possible states. If the value of all the $x_i$ is updated simultaneously at each $k$ then the network is synchronous, otherwise it is asynchronous. With synchronous boolean networks, at each $k$, $\boldsymbol{x}(k)$ has a unique possible successor $\boldsymbol{x}(k+1)$: synchronous boolean networks are deterministic.

In the particular case where $k=k_0$, $\boldsymbol{x}(k_0)=\boldsymbol{x}_0$ is the initial state and, in deterministic dynamical systems such as synchronous boolean networks, determines entirely the trajectory $w=(\boldsymbol{x}(k_0),\dots,\boldsymbol{x}(k_{end}))$. $w$ is a sequence of length $k_{end}$\footnote{It is assumed that $k_0=1$.} and results from the iterative computation of $\boldsymbol{x}(k)$ from $k_0$ up to $k_{end}$.

This iterative computation can be seen as the discretization of a time interval: boolean networks are discrete dynamical systems as they simulate, discretely, the time course of the state vector. Furthermore, while boolean networks are networks on their own, in practice they can be used to model other networks such as biological networks: boolean networks are discrete dynamical systems which can be used to model the dynamic of biological networks.

The set $A=\lbrace a_1,\dots,a_p\rbrace$ of size $p$ containing exactly all the attractors $a_i$ is the attractor set. Due to the determinism of synchronous boolean networks, all the attractors are cycles. A cycle is a sequence $(\boldsymbol{x}_{1},\dots,\boldsymbol{x}_{q})$ of length $q$ such that $\forall j\in [\![1,q]\!]$, $\boldsymbol{x}_{j+1}=\boldsymbol{f}(\boldsymbol{x}_{j})$ and $\boldsymbol{x}_{q+1}=\boldsymbol{x}_{1}$: once the system reach a state $\boldsymbol{x}_{j}$ belonging to a cycle, it will successively visit its states $\boldsymbol{x}_{j+1},\dots,\boldsymbol{x}_{q},\boldsymbol{x}_{1},\dots,\boldsymbol{x}_{j}$ for infinity. In the particular case where $q=1$, the cycle is a point attractor. The set $B_i\subseteq S$ containing exactly all the $\boldsymbol{x}\in S$ from which $a_i$ can be reached is its basin of attraction. With deterministic dynamical systems such as synchronous boolean networks, the family of sets $(B_1,\dots,B_p)$ is a partition of $S$.

\subsection{Definitions}
Some particular concepts used in this work should be formally defined. Given a synchronous boolean network modeling the dynamic of a biological network bore by an organism:
\begin{itemize}
\item \emph{physiological phenotype}: a phenotype which does not impair the quantity or quality of life of the organism which exhibits it.
\item \emph{pathological phenotype}: a phenotype which impairs the quantity or quality of life of the organism which exhibits it.
\item \emph{variant (of a biological network)}: a biological network obtained from the original one where some modifications have occurred in its structure.
\item \emph{physiological variant}: a variant of the biological network which produces only physiological phenotypes.
\item \emph{pathological variant}: a variant of the biological network which produces at least one pathological phenotype.
\item \emph{physiological attractor set}: the attractor set $A_{physio}$ of the physiological variant.
\item \emph{pathological attractor set}: the attractor set $A_{patho}$ of the pathological variant.
\item \emph{physiological boolean transition function}: the boolean transition function $\boldsymbol{f}_{physio}$ of the physiological variant.
\item \emph{pathological boolean transition function}: the boolean transition function $\boldsymbol{f}_{patho}$ of the pathological variant.
\item \emph{run}: an iterative computation of the state vector value $\boldsymbol{x}(k)$ starting from an initial state $\boldsymbol{x}(k_0)=\boldsymbol{x}_0$ until an attractor $a_i$ is reached. It returns the trajectory $w=(\boldsymbol{x}(k_0),\dots,\boldsymbol{x}(k_{end}))$ where $k_{end}$ depends on when $a_i$ is reached and hence on $\boldsymbol{x}_0$.
\item \emph{physiological attractor}: an attractor $a_i$ such that $a_i\in A_{physio}$
\item \emph{pathological attractor}: an attractor $a_i$ such that $a_i\notin A_{physio}$
\item \emph{modality}: the nature of the functional perturbation $moda_i$ applied to an entity $v_j\in V$ of the network, either activating ($moda_i=1$) or inactivating ($moda_i=0$): at each iteration $k$, $moda_i$ overwrites $f_j(\boldsymbol{x}(k))$ and hence $x_j(k+1)=moda_i$.
\item \emph{target}: an entity $v_j\in V$ of the network on which a modality $moda_i$ is applied.
\item \emph{bullet}: a couple $(c_{targ},c_{moda})$ where $c_{targ}=(targ_1,\dots,targ_r)$ is a combination without repetition of targets $targ_i$ and where $c_{moda}=(moda_1,\dots,moda_r)$ is an arrangement with repetition of modalities $moda_i$, $r\in [\![1,n]\!]$ being the number of targets in the bullet. $moda_i$ is intended to be applied to $targ_i$.
\item \emph{therapeutic bullet}: a bullet which makes $A_{patho}\subseteq A_{physio}$.
\item \emph{silver bullet}: a therapeutic bullet which makes $A_{patho}\varsubsetneq A_{physio}$.
\item \emph{golden bullet}: a therapeutic bullet which makes $A_{patho}=A_{physio}$.
\end{itemize}

The assumed link between phenotypes and attractors is the reason why attractors are qualified as either physiological or pathological according to the phenotype they produce and the reason why target identification aims at manipulating the attractor set of the pathological variant.

\subsection{Steps of the algorithm}
The algorithm has two goals: i) finding therapeutic bullets and ii) classifying them as either golden or silver. A therapeutic bullet is intended to make the pathological variant unable to reach pathological attractors, that is to make $A_{patho}\subseteq A_{physio}$. If such a bullet is applied to the pathological variant, the organism bearing it no longer exhibits the associated pathological phenotypes: this is the primary goal. However, a therapeutic bullet does not necessarily preserve or restore all the physiological attractors. If a therapeutic bullet preserves or restores all the physiological attractors, that is if $A_{patho}=A_{physio}$, it is a golden one but if $A_{patho}\varsubsetneq A_{physio}$ it is a silver one: this classification is the secondary goal.

To do this, given a physiological and a pathological variant, that is $\boldsymbol{f}_{physio}$ and $\boldsymbol{f}_{patho}$, the algorithm follows five steps:
\begin{enumerate}
\item with $\boldsymbol{f}_{physio}$ it computes the control attractor set $A_{physio}$
\item it randomly generates bullets and for each of them it performs the three following steps
\item with $\boldsymbol{f}_{patho}$ under the effect of the bullet it computes the variant attractor set $A_{patho}$
\item it assesses the therapeutic potential of the bullet by comparing $A_{physio}$ and $A_{patho}$ to detect pathological attractors
\item if the bullet is a therapeutic one, it classifies it as either golden or silver by comparing $A_{physio}$ and $A_{patho}$ for equality
\end{enumerate}
which can be written:
\begin{algorithmic}[1]
\STATE with $\boldsymbol{f}_{physio}$ compute $A_{physio}$
\STATE generate $bullet\_set$
\FOR{$bullet\in bullet\_set$}
    \STATE with $\boldsymbol{f}_{patho}$ plus $bullet$ compute $A_{patho}$
    \IF{$A_{patho}\subseteq A_{physio}$}
        \STATE $bullet$ is therapeutic
        \IF {$A_{patho}=A_{physio}$}
            \STATE $bullet$ is golden
        \ELSE
            \STATE $bullet$ is silver
        \ENDIF
    \ENDIF
\ENDFOR
\end{algorithmic}

\subsubsection{Step 1: computing $A_{physio}$}
First of all, $A_{physio}$ has to be computed since it is used as the control and hence determines what is pathological and what is not. To this end, runs are performed with $\boldsymbol{f}_{physio}$ and the reached $a_i$ are stored in $A_{physio}$. However, $\boldsymbol{x}_0\in S$ and $size(S)$ increases exponentially with $n$. Even for a reasonable $n$, $size(S)$ explodes: more than one million of possible $\boldsymbol{x}_0$ for $n=20$. One solution ensuring that all the possible $a_i$ are reached is to start a run from each of the possible $\boldsymbol{x}_0$, that is from each of the $\boldsymbol{x}\in S$. In practice this is not feasible for an arbitrary $n$ because the required computational resources can be too demanding. For example, assuming that a run requires one millisecond of computation and assuming that $n=50$, performing a run starting from each of the $2^{50}$ $\boldsymbol{x}\in S$ requires nearly 36 thousand years, definitively not a practical duration. However, given that with deterministic dynamical systems such as synchronous boolean networks $(B_1,\dots,B_p)$ is a partition of $S$, a solution is to randomly select a subset $D\subseteq S$ of a given size containing the $\boldsymbol{x}_0$ to start from. In order to avoid bias in the random selection, a uniform distribution should be used. The stumbling block of this solution is that it does not ensure that at least one $\boldsymbol{x}_0$ per $B_i$ is selected and then it does not ensure that all the $a_i$ are reached. This stumbling block holds only if $size(D)<size(S)$.

Again given that synchronous boolean networks are deterministic, if a run visits a state which has already been visited during a previous run, its destination, that is the attractor it will reach, has already been found. Hence, the run can be immediately stopped and the algorithm can directly jump to the next one. To implement this, the previous trajectories are stored in a set $H$, the history, and at each $k$ the algorithm checks if $\exists w\in H: \boldsymbol{x}(k)\in w$. If this check is positive then the algorithm jumps to the next run.

Identifying the attractors is relatively easy with deterministic dynamical systems such as synchronous boolean networks. Indeed, in this case, attractors are cycles. Therefore, to identify a cycle, the algorithm checks at each $k$ if $\boldsymbol{x}(k+1)$ has already been visited during the current run, that is if $\exists k'\in [\![1,k]\!]: \boldsymbol{x}(k+1)=\boldsymbol{x}(k')$. If this check is positive then $a_i=(\boldsymbol{x}(k'),\dots ,\boldsymbol{x}(k))$.

This step can be written:
\begin{algorithmic}[1]
\REQUIRE $size(D)$
\STATE $size(D)=min(size(D),2^n)$
\STATE generate $D\subseteq S$
\STATE $H=\lbrace \rbrace$
\STATE $A_{physio}=\lbrace \rbrace$
\FOR{$x_0\in D$}
    \STATE $k=1$
    \STATE $\boldsymbol{x}(1)=x_0$
    \WHILE{$1$}
        \IF{$\exists w\in H: \boldsymbol{x}(k)\in w$}
            \STATE \textbf{break}
        \ENDIF
        \STATE $\boldsymbol{x}(k+1)=\boldsymbol{f}_{physio}(\boldsymbol{x}(k))$
        \IF{$\exists k'\in [\![1,k]\!]: \boldsymbol{x}(k+1)=\boldsymbol{x}(k')$}
            \STATE $A_{physio}=A_{physio}\cup \lbrace (\boldsymbol{x}(k'),\dots ,\boldsymbol{x}(k))\rbrace$
            \STATE \textbf{break}
        \ENDIF
        \STATE $k=k+1$
    \ENDWHILE
    \STATE $H=H\cup \lbrace (\boldsymbol{x}(1),\dots ,\boldsymbol{x}(k))\rbrace$
\ENDFOR
\ENSURE $A_{physio}$
\STATE do step 2
\end{algorithmic}
Line 2 catches the mistake $size(D)>size(S)$. It should be noted that more sophisticated algorithms intended to find boolean network attractors are already available, such as the ones proposed by Zheng \textit{et al} \cite{zheng2013efficient}.

\subsubsection{Step 2: generating bullets}
The bullets are the candidate perturbations to apply to the pathological variant to make it unable to reach pathological attractors and hence to make it unable to produce pathological phenotypes. Generating a bullet is to choose some $targ_i\in V$ and to choose for each of them a $moda_i\in \lbrace 0,1\rbrace$. In this work there is no time sequencing in the target engagement nor in the modality choice. This means that, given a bullet and during a run, all the $targ_i$ are engaged simultaneously and constantly and that the $moda_i$ do not change during the run. Hence, in this setting, choosing more than once the same $targ_i$ is senseless while it is possible to choose the same $moda_i$ for more than one $targ_i$. Therefore, a bullet is a combination $c_{targ}$ without repetition of $targ_i$ together with an arrangement $c_{moda}$ with repetition of $moda_i$. If bullets containing $r$ targets have to be generated then there are $n!/(r!\cdot (n-r)!)$ possible $c_{targ}$ and for each of them there are $2^{r}$ possible $c_{moda}$. This raises the same computational problem as with the state space size explosion since there are $(n!\cdot 2^{r})/(r!\cdot (n-r)!)$ possible bullets. For example, assuming that $n=50$ and that $r=3$, there are more than 150 thousand possible bullets. Knowing that the algorithm, as explained below, computes one attractor set per bullet, the computation time becomes practically unfeasible. To overcome this, the algorithm asks for $r$ as an interval $[\![r_{min},r_{max}]\!]$, asks for a maximum number $max_{targ}$ of $c_{targ}$ to generate and a maximum number $max_{moda}$ of $c_{moda}$ to test for each $c_{targ}$. Then the algorithm generates a set $C_{targ}$ of $c_{targ}$ with $size(C_{targ})\leq max_{targ}$ by randomly selecting, along a uniform distribution and without repetition, entities in the network. In the same way, the algorithm generates a set $C_{moda}$ of $c_{moda}$ with $size(C_{moda})\leq max_{moda}$ by randomly choosing, along a uniform distribution and with repetition, modalities as either activating ($=1$) or inactivating ($=0$). The result is the bullets: per $r\in[\![r_{min},r_{max}]\!]$, a $C_{targ}$ together with a $C_{moda}$. As with the state space size explosion, the stumbling block of this method is that it does not ensure that all the possible $c_{targ}$ together with all the possible $c_{moda}$ are tested. This stumbling block holds only if $max_{targ}<n!/(r!\cdot (n-r)!)$ or $max_{moda}<2^{r}$.

This step can be written:
\begin{algorithmic}[1]
\REQUIRE $r_{min},r_{max},max_{targ},max_{moda}$
\STATE $r_{max}=min(r_{max},n)$
\STATE $golden\_set=\lbrace \rbrace$
\STATE $silver\_set=\lbrace \rbrace$
\FOR{$r\in [\![r_{min},r_{max}]\!]$}
    \STATE $max_{targ}^{r}=min(max_{targ},n!/(r!\cdot (n-r)!))$
    \STATE $max_{moda}^{r}=min(max_{moda},2^{r})$
    \STATE $C_{targ}=\lbrace \rbrace$
    \STATE $C_{moda}=\lbrace \rbrace$
    \WHILE{$size(C_{targ})<max_{targ}^{r}$}
        \STATE generate $c_{targ}\notin C_{targ}$
        \STATE $C_{targ}=C_{targ}\cup \lbrace c_{targ}\rbrace$
    \ENDWHILE
    \WHILE{$size(C_{moda})<max_{moda}^{r}$}
        \STATE generate $c_{moda}\notin C_{moda}$
        \STATE $C_{moda}=C_{moda}\cup \lbrace c_{moda}\rbrace$
    \ENDWHILE
    \STATE do steps 3 to 5
\ENDFOR
\ENSURE $golden\_set$
\ENSURE $silver\_set$
\end{algorithmic}
Line 2 catches the mistake $r>n$. Lines 3--4 create the sets in which the therapeutic bullets which will be found during the step 4 will be classified as either golden or silver during the step 5. Lines 6--7 catch the mistake where $max_{targ}$ or $max_{moda}$ is greater than its maximum, which depends on $r$ hence the creation of $max_{targ}^{r}$ or $max_{moda}^{r}$ to preserve the original supplied value. Lines 11,15 ensure that only novel $c_{targ}$ and $c_{moda}$ are generated.

\subsubsection{Step 3: computing $A_{patho}$}
Having the control attractor set $A_{physio}$ and a bullet $(c_{targ},c_{moda})\in C_{targ}\times C_{moda}$, the algorithm computes the variant attractor set $A_{patho}$ under the effect of the bullet by almost the same way $A_{physio}$ was computed during the step 1. However, in this step, $\boldsymbol{f}_{patho}$ is used instead of $\boldsymbol{f}_{physio}$ and the bullet is applied: at each $k$, $f_j(\boldsymbol{x}(k))$ is overwritten by $moda_i\in c_{moda}$, that is $x_j(k+1)=moda_i$, provided that $v_j=targ_i\in c_{targ}$.

In order to apply all the generated bullets, the algorithm uses two nested $for$ loops: for each $c_{targ}\in C_{targ}$ it uses successively all the $c_{moda}\in C_{moda}$: $C_{moda}$ contains all the $c_{moda}$ to test for each $c_{targ}\in C_{targ}$. For each of these couples $(c_{targ},c_{moda})$ the algorithm computes the corresponding $A_{patho}$ and does the steps 4 and 5.

This step can be written:
\begin{algorithmic}[1]
\FOR{$c_{targ}\in C_{targ}$}
    \FOR{$c_{moda}\in C_{moda}$}
        \STATE $H=\lbrace \rbrace$
        \STATE $A_{patho}=\lbrace \rbrace$
        \FOR{$x_0\in D$}
            \STATE $k=1$
            \STATE $\boldsymbol{x}(1)=x_0$
            \WHILE{$1$}
                \IF{$\exists w\in H: \boldsymbol{x}(k)\in w$}
                    \STATE \textbf{break}
                \ENDIF
                \STATE $\boldsymbol{x}(k+1)=\boldsymbol{f}_{patho}(\boldsymbol{x}(k))$
                \FOR{$targ_i\in c_{targ}$}
                    \FOR{$v_j\in V$}
                        \IF{$v_j=targ_i$}
                            \STATE $x_j(k+1)=moda_i$
                        \ENDIF
                    \ENDFOR
                \ENDFOR
                \IF{$\exists k'\in [\![1,k]\!]: \boldsymbol{x}(k+1)=\boldsymbol{x}(k')$}
                    \STATE $A_{patho}=A_{patho}\cup \lbrace (\boldsymbol{x}(k'),\dots ,\boldsymbol{x}(k))\rbrace$
                    \STATE \textbf{break}
                \ENDIF
                \STATE $k=k+1$
            \ENDWHILE
            \STATE $H=H\cup \lbrace (\boldsymbol{x}(1),\dots ,\boldsymbol{x}(k))\rbrace$
        \ENDFOR
        \STATE do step 4 and 5
    \ENDFOR
\ENDFOR
\end{algorithmic}
Lines 13--19 are where the bullet is applied.

\subsubsection{Step 4: identifying therapeutic bullets}
To identify therapeutic bullets among the generated ones, for each tested bullet in the step 3 and once the corresponding $A_{patho}$ is obtained, the algorithm compares it with $A_{physio}$ to check if $A_{patho}\subseteq A_{physio}$. This check ensures that, under the effect of the bullet, all the pathological attractors were removed and ensures that if new attractors have appeared they are physiological ones. If this check is positive then the bullet is a therapeutic one and the algorithm pursues with the step 5.

This step can be written:
\begin{algorithmic}[1]
\IF{$A_{patho}\subseteq A_{physio}$}
    \STATE do step 5
\ENDIF
\end{algorithmic}

\subsubsection{Step 5: assessing therapeutic bullets}
The therapeutic bullets are qualified as either silver or golden according to their ability at making the pathological variant able to reach the physiological attractors. Indeed, all therapeutic bullets, either golden or silver, are primarily intended to remove all the pathological attractors without creating new ones, that is to make $A_{patho}\subseteq A_{physio}$. However, this does not imply that all the therapeutic bullets preserve or restore the physiological attractors. This is why they are classified as either golden or silver. A golden bullet preserves or restores all the physiological attractors: $A_{patho}=A_{physio}$ while a silver bullet does not: $A_{patho}\varsubsetneq A_{physio}$.

Hence, in the setting of synchronous boolean modeling, golden bullets are perfect therapies while silver bullets are not. However, since precious things are rare and since gold is rarer than silver, finding a golden bullet is less likely than finding a silver one. Indeed, given that more constraints are required for a therapeutic bullet to be a golden one, it is more likely that the identified therapeutic bullets are silver ones.

Practically, again in the setting of synchronous boolean modeling, an organism which bears a pathological variant treated by a therapeutic bullet no longer exhibits the associated pathological phenotypes. Moreover, if the therapeutic bullet is a golden one, the organism has the same phenotype than its healthy counterpart. However, if the therapeutic bullet is a silver one, the organism fails to exhibit at least one of the physiological phenotypes. With a silver bullet this is a matter of choice: what is the less detrimental for the ill organism between a silver bullet and no therapeutic bullet.

This step can be written:
\begin{algorithmic}[1]
\IF{$A_{patho}=A_{physio}$}
    \STATE $golden\_set=golden\_set\cup \lbrace (c_{targ},c_{moda})\rbrace$
\ELSE
    \STATE $silver\_set=silver\_set\cup \lbrace (c_{targ},c_{moda})\rbrace$
\ENDIF
\end{algorithmic}

\subsection{The algorithm in one block}
The algorithm was described step by step for the sake of clarity. Below is the algorithm in one block.
\begin{algorithmic}[1]
\REQUIRE $size(D)$
\STATE $size(D)=min(size(D),2^n)$
\STATE generate $D\subseteq S$
\STATE $H=\lbrace \rbrace$
\STATE $A_{physio}=\lbrace \rbrace$
\FOR{$x_0\in D$}
    \STATE $k=1$
    \STATE $\boldsymbol{x}(1)=x_0$
    \WHILE{$1$}
        \IF{$\exists w\in H: \boldsymbol{x}(k)\in w$}
            \STATE \textbf{break}
        \ENDIF
        \STATE $\boldsymbol{x}(k+1)=\boldsymbol{f}_{physio}(\boldsymbol{x}(k))$
        \IF{$\exists k'\in [\![1,k]\!]: \boldsymbol{x}(k+1)=\boldsymbol{x}(k')$}
            \STATE $A_{physio}=A_{physio}\cup \lbrace (\boldsymbol{x}(k'),\dots ,\boldsymbol{x}(k))\rbrace$
            \STATE \textbf{break}
        \ENDIF
        \STATE $k=k+1$
    \ENDWHILE
    \STATE $H=H\cup \lbrace (\boldsymbol{x}(1),\dots ,\boldsymbol{x}(k))\rbrace$
\ENDFOR
\ENSURE $A_{physio}$
\REQUIRE $r_{min},r_{max},max_{targ},max_{moda}$
\STATE $r_{max}=min(r_{max},n)$
\STATE $golden\_set=\lbrace \rbrace$
\STATE $silver\_set=\lbrace \rbrace$
\FOR{$r\in [\![r_{min},r_{max}]\!]$}
    \STATE $max_{targ}^{r}=min(max_{targ},n!/(r!\cdot (n-r)!))$
    \STATE $max_{moda}^{r}=min(max_{moda},2^{r})$
    \STATE $C_{targ}=\lbrace \rbrace$
    \STATE $C_{moda}=\lbrace \rbrace$
    \WHILE{$size(C_{targ})<max_{targ}^{r}$}
        \STATE generate $c_{targ}\notin C_{targ}$
        \STATE $C_{targ}=C_{targ}\cup \lbrace c_{targ}\rbrace$
    \ENDWHILE
    \WHILE{$size(C_{moda})<max_{moda}^{r}$}
        \STATE generate $c_{moda}\notin C_{moda}$
        \STATE $C_{moda}=C_{moda}\cup \lbrace c_{moda}\rbrace$
    \ENDWHILE
    \FOR{$c_{targ}\in C_{targ}$}
        \FOR{$c_{moda}\in C_{moda}$}
            \STATE $H=\lbrace \rbrace$
            \STATE $A_{patho}=\lbrace \rbrace$
            \FOR{$x_0\in D$}
                \STATE $k=1$
                \STATE $\boldsymbol{x}(1)=x_0$
                \WHILE{$1$}
                    \IF{$\exists w\in H: \boldsymbol{x}(k)\in w$}
                        \STATE \textbf{break}
                    \ENDIF
                    \STATE $\boldsymbol{x}(k+1)=\boldsymbol{f}_{patho}(\boldsymbol{x}(k))$
                    \FOR{$targ_i\in c_{targ}$}
                        \FOR{$v_j\in V$}
                            \IF{$v_j=targ_i$}
                                \STATE $x_j(k+1)=moda_i$
                            \ENDIF
                        \ENDFOR
                    \ENDFOR
                    \IF{$\exists k'\in [\![1,k]\!]: \boldsymbol{x}(k+1)=\boldsymbol{x}(k')$}
                        \STATE $A_{patho}=A_{patho}\cup \lbrace (\boldsymbol{x}(k'),\dots ,\boldsymbol{x}(k))\rbrace$
                        \STATE \textbf{break}
                    \ENDIF
                    \STATE $k=k+1$
                \ENDWHILE
                \STATE $H=H\cup \lbrace (\boldsymbol{x}(1),\dots ,\boldsymbol{x}(k))\rbrace$
            \ENDFOR
            \IF{$A_{patho}\subseteq A_{physio}$}
                \IF{$A_{patho}=A_{physio}$}
                    \STATE $golden\_set=golden\_set\cup \lbrace (c_{targ},c_{moda})\rbrace$
                \ELSE
                    \STATE $silver\_set=silver\_set\cup \lbrace (c_{targ},c_{moda})\rbrace$
                \ENDIF
            \ENDIF
        \ENDFOR
    \ENDFOR
\ENDFOR
\ENSURE $golden\_set$
\ENSURE $silver\_set$
\end{algorithmic}

\subsection{Working example}
To test the algorithm and to illustrate its capacities, it was applied on a published boolean model of the mammalian cell cycle \cite{faure2006dynamical}. This model was chosen for several reasons: i) the authors have done a synchronous computation of their boolean network: synchronous boolean networks are the study objects of the present work, ii) their boolean network models a mammalian biological system: the closer to human physiology the model is the better it illustrates the intended applications, iii) the cell cycle is a biological system at the heart of cancer, a widespread and severe disease in human health: this makes the working example more relevant, iv) their network comprises ten nodes: easily computable in the face of the corresponding state space and v) the authors have already computed the attractors of their boolean network: useful to validate the algorithm in computing attractors.

Below are the boolean functions describing their boolean network where, for the sake of readability, $x_i$ stands for $x_{i}(k)$ and $x_{i+}$ stands for $x_{i}(k+1)$.
{\tiny
\begin{IEEEeqnarray*}{lLl}
CycD_{+}&=&CycD\\
Rb_{+}&=&(\lnot CycD \land \lnot CycE \land \lnot CycA \land \lnot CycB) \lor (p27 \land \lnot CycD \land \lnot CycB)\\
E2F_{+}&=&(\lnot Rb \land \lnot CycA \land \lnot CycB) \lor (p27 \land \lnot Rb \land \lnot CycB)\\
CycE_{+}&=&E2F \land \lnot Rb\\
CycA_{+}&=&(E2F \land \lnot Rb \land \lnot Cdc20 \land \lnot(Cdh1 \land UbcH10)) \lor (CycA \land \lnot Rb \land \lnot Cdc20 \land \lnot(Cdh1 \land UbcH10))\\
p27_{+}&=&(\lnot CycD \land \lnot CycE \land \lnot CycA \land \lnot CycB) \lor (p27 \land \lnot(CycE \land CycA) \land \lnot CycB \land \lnot CycD)\\
Cdc20_{+}&=&CycB\\
Cdh1_{+}&=&(\lnot CycA \land \lnot CycB) \lor Cdc20 \lor (p27 \land \lnot CycB)\\
UbcH10_{+}&=&\lnot Cdh1 \lor (Cdh1 \land UbcH10 \land (Cdc20 \lor CycA \lor CycB))\\
CycB_{+}&=&\lnot Cdc20 \land \lnot Cdh1
\end{IEEEeqnarray*}
}

Having the example network, two variants of it are needed: the physiological one and the pathological one. The physiological variant is the network as is while the pathological variant is the network plus a constitutive activation or inactivation of at least one of its entities. For simplicity, and given the relatively small number of entities in the network, only one was chosen: the retinoblastoma protein $Rb$ for which a constitutive inactivation is applied. To implement this in the pathological variant, the corresponding $f_i$ becomes $Rb_{+}=0$ in $\boldsymbol{f}_{patho}$.
$Rb$ was chosen because its inactivation occurs in many cancers \cite{sherr2002rb} and hence a network bearing a constitutive inactivation of it should be a good example of a pathological variant.

\subsection{Implementation}
The algorithm was firstly implemented in Octave\footnote{\url{https://www.gnu.org/software/octave/}} for convenience and then in Fortran 95 compiled with GFortran\footnote{\url{https://www.gnu.org/software/gcc/fortran/}} for performance. The sources can be found on GitHub\footnote{\url{https://github.com/}} at \url{https://github.com/arnaudporet/kali-targ}.

\section{Results and discussion}
This section exposes the results of the five steps of the algorithm applied to the physiological and pathological variants of the working example.

\subsection{Results of step 1}
Thanks to the relatively small $size(S)$ of the working example, $size(D)$ was set to $size(S)=1024$. The algorithm returned the two following attractors:
\begin{equation*}
a_{1}=
\begin{matrix}
CycD:&1&1&1&1&1&1&1\\
Rb:&0&0&0&0&0&0&0\\
E2F:&0&1&1&1&0&0&0\\
CycE:&0&0&1&1&1&0&0\\
CycA:&0&0&0&1&1&1&1\\
p27:&0&0&0&0&0&0&0\\
Cdc20:&1&0&0&0&0&0&1\\
Cdh1:&1&1&1&1&0&0&0\\
UbcH10:&1&1&0&0&0&1&1\\
CycB:&0&0&0&0&0&1&1
\end{matrix}
\end{equation*}
\begin{equation*}
a_{2}=
\begin{matrix}
CycD:&0\\
Rb:&1\\
E2F:&0\\
CycE:&0\\
CycA:&0\\
p27:&1\\
Cdc20:&0\\
Cdh1:&1\\
UbcH10:&0\\
CycB:&0
\end{matrix}
\end{equation*}

The attractors are represented as matrices where, for an attractor of length $q$, lines correspond to the $x_i(k), k\in [\![1,q]\!]$ and where columns correspond to the $\boldsymbol{x}(k)$.
Hence $A_{physio}=\lbrace a_{1},a_{2}\rbrace$ which corresponds to what the authors have computed. By the way, $a_{1}$ and $a_{2}$ are the two physiological attractors. In term of phenotypes, $a_{1}$ corresponds to the accomplishment of a normal cell cycle while $a_{2}$ corresponds to quiescence.

\subsection{Results of steps 2 to 5}
The results of the steps 2 to 5 were grouped because only the therapeutic bullets found in the step 4 and classified in the step 5 are returned by the algorithm. The algorithm was launched with $r_{min}=1$ and $r_{max}=3$. Again due to the relatively small size of the working example, $max_{targ}$ and $max_{moda}$ were set to their maximum over $[\![r_{min};r_{max}]\!]$, that is $max_{targ}=120$ and $max_{moda}=8$. The algorithm returned the following therapeutic bullets:
\begin{equation*}
\begin{matrix}
+CycD&&silver\\
+CycD&-p27&silver\\
-CycD&+Rb&silver\\
+CycD&-Rb&silver
\end{matrix}
\end{equation*}
where $+$ means a therapeutic activation and $-$ a therapeutic inactivation. It should be noted that no golden bullets were found, a not surprising result since they are rarer than silver ones. Furthermore, given these results, the therapeutic activation of $Rb$ alone, which was pathologically inactivated, is not enough to remove the pathological attractors. Indeed, as seen in the third bullet, the therapeutic activation of $Rb$ must be accompanied by a therapeutic inactivation of $CycD$.

To better illustrate what was done to obtain these therapeutic bullets, here is $A_{patho}$ without the effect of a bullet:
\begin{equation*}
a_{3}=
\begin{matrix}
CycD:&0&0&0&0&0&0&0&0\\
Rb:&0&0&0&0&0&0&0&0\\
E2F:&1&1&1&1&0&0&0&0\\
CycE:&0&1&1&1&1&0&0&0\\
CycA:&0&0&1&1&1&1&1&0\\
p27:&1&1&1&0&0&0&0&0\\
Cdc20:&0&0&0&0&0&0&1&1\\
Cdh1:&1&1&1&1&0&0&0&1\\
UbcH10:&1&0&0&0&0&1&1&1\\
CycB:&0&0&0&0&0&1&1&0
\end{matrix}
\end{equation*}
\begin{equation*}
a_{4}=
\begin{matrix}
CycD:&1&1&1&1&1&1&1\\
Rb:&0&0&0&0&0&0&0\\
E2F:&1&1&1&0&0&0&0\\
CycE:&0&1&1&1&0&0&0\\
CycA:&0&0&1&1&1&1&0\\
p27:&0&0&0&0&0&0&0\\
Cdc20:&0&0&0&0&0&1&1\\
Cdh1:&1&1&1&0&0&0&1\\
UbcH10:&1&0&0&0&1&1&1\\
CycB:&0&0&0&0&1&1&0
\end{matrix}
\end{equation*}

$a_{4}=a_{1}\in A_{physio}$: $a_{4}$ is a physiological attractor. Indeed, it is possible that the pathological variant produces physiological attractors: $A_{patho}$ is not the set containing exactly all the pathological attractors, it is the attractor set of the pathological variant and it is possible that $A_{physio}\cap A_{patho}\neq \emptyset$. However $a_3\notin A_{physio}$: it is a pathological attractor. In term of phenotypes, $a_3$ may correspond to a somewhat degenerated cell cycle and is what a therapeutic bullet, being golden or silver, is intended to avoid.

Again to better illustrate what was done to obtain the therapeutic bullets, here is $A_{patho}$ under the effect of the third bullet:
\begin{equation*}
\begin{matrix}
CycD:&0\\
Rb:&1\\
E2F:&0\\
CycE:&0\\
CycA:&0\\
p27:&1\\
Cdc20:&0\\
Cdh1:&1\\
UbcH10:&0\\
CycB:&0
\end{matrix}
\end{equation*}
which is $a_{2}$. Hence, as expected for a therapeutic bullet, the pathological attractor $a_{3}$ was removed, but the physiological attractor $a_{1}$ was not restored: the third bullet is then a silver one. Consequently, with this bullet, no cell cycle occurs, being normal or degenerated, and the only reachable phenotype is quiescence. While disabling the cell cycle of cancer cells is beneficial to the ill organism, what about disabling the cell cycle of its normal cell. As mentioned above, with silver bullets this is a matter of choice between a silver bullet and no therapeutic bullet.

\section{Conclusions}
Under the assumption stating that dynamical system attractors and biological network phenotypes are linked when the first one models the second one, the results showed that the algorithm succeed in performing the proposed \textit{in silico} target identification by returning four effective therapeutic bullets for a pathological variant of the mammalian cell cycle relevant in diseases such as cancer. Consequently, it can be used on other synchronous boolean models of biological networks involved in disease pathophysiologies for \textit{in silico} target identification provided that the physiological and pathological variants are known. However, one should keep in mind that the findings produced by the algorithm are conditional upon the validity of the assumption linking attractors and phenotypes.

It should be noted that target identification, being \textit{in silico} or not, is a piece belonging to a wider machinery: target discovery. Indeed, having an \textit{in silico} demonstrated potential target implies that further work has to be done to obtain a drug which will be effective \textit{in vivo}. Among other characteristics, such a drug has to be absorbed by the organism, has to reach its target and has to be non-toxic at therapeutic dosages. Furthermore, as with any \textit{in silico} evidence, it should be validated in practice: there is a bridge to cross between theory and practice. Nevertheless, the present algorithm is expected to find a place in, and to contribute to, the endeavors done in therapeutic researches.

Regarding further investigations that could be done on this one, extending the algorithm for asynchronous boolean networks is important because such models are likely to better approach the dynamic of biological systems \cite{saadatpour2010attractor}. Indeed, in a biological system, events can be subjected to stochasticity, they do not necessarily occur simultaneously or they do not belong to the same time scale, three things that a synchronous updating does not take into account. Furthermore, one of the limitations of boolean models is that their variables can take only two values. However, in reality, things are not necessarily binary and variables should be able to take much more values for more accuracy. Without leaving the logic-based framework, one solution is to use more general forms of logic such as multivalued logic or fuzzy logic \cite{zadeh1988fuzzy}.

\bibliography{computing_boolean_network_attractors_for_target_identification}
\bibliographystyle{unsrt}

\end{document}

%##############################################################################%
%#############################      LICENSE       #############################%
%#############################    BSD 3-Clause    #############################%
%##############################################################################%

%Copyright (c) 2013-2014, Arnaud Poret
%All rights reserved.

%Redistribution and use in source and binary forms, with or without modification,
%are permitted provided that the following conditions are met:

%1. Redistributions of source code must retain the above copyright notice, this
%list of conditions and the following disclaimer.

%2. Redistributions in binary form must reproduce the above copyright notice,
%this list of conditions and the following disclaimer in the documentation and/or
%other materials provided with the distribution.

%3. Neither the name of the copyright holder nor the names of its contributors
%may be used to endorse or promote products derived from this software without
%specific prior written permission.

%THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
%ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
%WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
%DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
%ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
%(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
%LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
%ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
%(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
%SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

